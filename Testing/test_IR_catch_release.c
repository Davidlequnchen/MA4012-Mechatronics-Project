#pragma config(Motor,  port2,           servoLeft,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port3,           servoRight,    tmotorServoStandard, openLoop)
#pragma config(Motor,  port4,           leftWheel,     tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           rightWheel,     tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Sensor, in2,    shortDistanceSensor, sensorAnalog)
#pragma config(Sensor, in3,    longDistanceSensor, sensorAnalog)
#pragma config(Sensor, in4,    enemyDistanceSensor, sensorAnalog)
#pragma config(Sensor, dgtl2,  BackRightSwitch, sensorTouch)
#pragma config(Sensor, dgtl3,  BackLeftSwitch, sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//---------------------------function definitions----------------------------------
void differnetial_drive (float leftLevel, float rightLevel);
bool search_ball();
bool move_to_ball();
void release_ball();
void catch_ball();
//---------------------------tasks definitions-------------------------------------
task competition();
task detection();
//---------------------------global variable definitions---------------------------
bool ballDetected = false;
bool catchmentReady = false;
bool enemyDetected = false;



/*--- differential drive -----
direction: 1 (forward), -1 (backward)
speedMode: 0(stop), 1(1/4 speed),2,3,4(max speed), minus/plus sign
*/
void differnetial_drive(float leftLevel, float rightLevel)
{
	float voltageRight;
	float voltageLeft;

	voltageLeft = leftLevel*30;
	voltageRight = rightLevel*30;

	motor[rightWheel] = -voltageRight;
	motor[leftWheel]  = voltageLeft;
}

void catch_ball()	//can change to bool when include checking ball
{
    // move forward a little to secure the ball
		clearTimer(T1);
		while(time1[T1]<50)
		{
	     differnetial_drive(-0.7, -0.7);
		}


    motor[servoRight] = 45;       // 40
		motor[servoLeft] = -55;       // -50
		wait1Msec(550);

		// move forward a little to secure the ball
		clearTimer(T1);
		while(time1[T1]<800)
		{
	     differnetial_drive(1, 1);
		}
}


void release_ball()
{
		clearTimer(T1);
		while(time1[T1]<10000) //
		{
	     differnetial_drive(-1, -1); // rotate back
	     if (SensorValue(BackLeftSwitch)!=0 && SensorValue(BackRightSwitch)!=0)
	     {
	       // servo release the ball
	        motor[servoRight] = -45;       // -35
					motor[servoLeft] = 90;       // 60
					wait1Msec(1000);

	        differnetial_drive(0, 0); // rotate back
	     }
		}
}



/*
First action, move half of the arena

void start_move()
{
    clearTimer(T1);
		while(time1[T1]<1000) // search for 1.6 seconds
		{
			// if not detected, keep turning CCW within this 1.6 second (90 degree)  ///////////////
      differnetial_drive(3,3); // go straight
		}
}
*/

// return true if ball is detected, otherwise, keep searching
bool search_ball()
{
	while(true) // keep searching
	{
		clearTimer(T1);
		while(time1[T1]<1800) // search for 1.6 seconds (level 1),,, level2 -- 0.8 sec
		{
			if(ballDetected) // if either L1 or L3 detect something
			{
				differnetial_drive(1.5,-1.5); //stop
				wait1Msec(50);
				return true;
			}

			// if not detected, keep turning CCW within this 1.6 second (90 degree)  ///////////////
      differnetial_drive(-1.5, 1.5); // rotate CCW
		}
		return false;
	}

}


bool move_to_ball()
{
	while (ballDetected)
  {
  	//move towards the ball
		//adjust the speed according to the distance
		if (catchmentReady == true)
	  {
			differnetial_drive(0,0);
			wait1Msec(1000);
			catch_ball();
			return true;
	  }
	  else{
	    differnetial_drive(0.8,0.8);
	    wait1Msec(100);
	  }
  }
  return false;
}



void wait_for_on()
{
	//while(SensorValue[startSwitch] == 0)
	//{
		// while start switch not activated, wait inside the loop
	//}

	// start the tasks (multi-tasking parallel thread)
	startTask(competition);
	// startTask(detection); // start parallel program for ball detection

}

/*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------Tasks (Parallel-runing programs (threads))------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*/

task competition()
{
	//start_move();         // move half of arena first
	startTask(detection); // start parallel program for ball detection

	while(true)
	{
		if(search_ball()) // check if the ball is detected from either L1 or L3
		{
			if(move_to_ball())
			{
				differnetial_drive(0,0); // stop
				wait1Msec(500);
				release_ball();
			}
		}
	}//end of while true
}



task detection()
{
	// this will always run in the background
	while(true)
	{
		if (SensorValue[enemyDistanceSensor] > 600)     //L1 (left) sensor detects something
		{
			enemyDetected = true;
		}
		else if (SensorValue[enemyDistanceSensor] < 600)     //L1 (left) sensor detects something
		{
			enemyDetected = false;
		}

		if((SensorValue[shortDistanceSensor] > 100 || SensorValue[longDistanceSensor] > 100) && enemyDetected == false)
	  {
			ballDetected = true;
		}

		if((SensorValue[longDistanceSensor] > 1500 || SensorValue[shortDistanceSensor] > 500)  && enemyDetected == false)    //L2 (middle) sensor detects the enemy
		{
			// 1500, 500
			catchmentReady = true;
		}
		else{
			ballDetected = false;
			catchmentReady = false;
		}
	}//end of while

	return;
}//end of task


// main task
task main()
{
	//startTask(detection); // start parallel program for ball detection
	wait_for_on();
	while(true)
  {
  	wait1Msec(1);
    // Keep the program alive
  }
}//end of main
