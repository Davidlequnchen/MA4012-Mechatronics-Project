#pragma config(Sensor, in2,    shortDistanceSensor, sensorAnalog)
#pragma config(Sensor, in3,    longDistanceSensor, sensorAnalog)
#pragma config(Sensor, in4,    enemyDistanceSensor, sensorAnalog)
#pragma config(Sensor, dgtl1,  startSwitch,    sensorTouch)
#pragma config(Sensor, dgtl2,  BackRightSwitch, sensorTouch)
#pragma config(Sensor, dgtl3,  BackLeftSwitch, sensorTouch)
#pragma config(Sensor, dgtl8,  compassSupply,  sensorDigitalOut)
#pragma config(Sensor, dgtl9,  compassNorth,   sensorDigitalIn)
#pragma config(Sensor, dgtl10, compassEast,    sensorDigitalIn)
#pragma config(Sensor, dgtl11, compassSouth,   sensorDigitalIn)
#pragma config(Sensor, dgtl12, compassWest,    sensorDigitalIn)
#pragma config(Motor,  port2,           servoLeft,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port3,           servoRight,    tmotorServoStandard, openLoop)
#pragma config(Motor,  port4,           leftWheel,     tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           rightWheel,    tmotorVex393_MC29, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NORTH 0
#define NORTHEAST 1
#define EAST 2
#define SOUTHEAST 3
#define SOUTH 4
#define SOUTHWEST 5
#define WEST 6
#define NORTHWEST 7
// global variable
int global_orientation;


//---------------------------function definitions----------------------------------
void differnetial_drive (float leftLevel, float rightLevel);
bool search_ball();
bool move_to_ball();
void release_ball();
void catch_ball();
void align_orientation_with_collection();
//---------------------------tasks definitions-------------------------------------
task competition();
task detection();
task detection_others();
//---------------------------global variable definitions---------------------------
bool ballDetected = false;
bool catchmentReady = false;
bool enemyDetected = false;



/*--- differential drive -----
direction: 1 (forward), -1 (backward)
speedMode: 0(stop), 1(1/4 speed),2,3,4(max speed), minus/plus sign
*/
void differnetial_drive(float leftLevel, float rightLevel)
{
	float voltageRight;
	float voltageLeft;

	voltageLeft = leftLevel*30;
	voltageRight = rightLevel*30;

	motor[rightWheel] = -voltageRight;
	motor[leftWheel]  = voltageLeft;
}

void catch_ball()	//can change to bool when include checking ball
{
    // move forward a little to secure the ball
		clearTimer(T1);
		while(time1[T1]<50)
		{
	     differnetial_drive(-0.7, -0.7);
		}


    motor[servoRight] = 45;       // 40
		motor[servoLeft] = -55;       // -50
		wait1Msec(550);

		// move forward a little to secure the ball
		clearTimer(T1);
		while(time1[T1]<800)
		{
	     differnetial_drive(1, 1);
		}
}


void release_ball()
{
   	align_orientation_with_collection();
    wait1Msec(500);


    clearTimer(T1);
		while(time1[T1]<10000) //
		{
	     differnetial_drive(-1, -1); // rotate back
	     if (SensorValue(BackLeftSwitch)!=0 && SensorValue(BackRightSwitch)!=0)
	     {
	       // servo release the ball
	        motor[servoRight] = -45;       // -35
					motor[servoLeft] = 90;       // 60
					wait1Msec(1000);

	        differnetial_drive(0, 0); // rotate back
	     }
		}
}


///------------------------------------------------------
void align_orientation_with_collection()
{
	//rotate to align the orientation with the collection place
	if(global_orientation==EAST||global_orientation==NORTHEAST||global_orientation==SOUTH ||global_orientation==SOUTHEAST)
	{
		while(global_orientation!=NORTH)
		{
			differnetial_drive(-2,2);//CCW
		}
	}
	else if(global_orientation==WEST||global_orientation==NORTHWEST||global_orientation==SOUTHWEST)
	{
		while(global_orientation!=NORTH)
		{
			differnetial_drive(2,-2);//CW
		}
	}
	else if (global_orientation==NORTH)
  {
		differnetial_drive(0,-0);//stop
  }
}
///------------------------------------------------------

void read_orientation()
{
	int temp = 8*SensorValue(compassWest)+4*SensorValue(compassSouth)+2*SensorValue(compassEast)+SensorValue(compassNorth);
	switch(temp) {
	case 14:
		global_orientation = NORTH;
		break;
	case 13:
		global_orientation = EAST;
		break;
	case 11:
		global_orientation = SOUTH;
		break;
	case 7:
		global_orientation = WEST;
		break;
	case 12:
		global_orientation = NORTHEAST;
		break;
	case 9:
		global_orientation = SOUTHEAST;
		break;
	case 3:
		global_orientation = SOUTHWEST;
		break;
	case 6:
		global_orientation = NORTHWEST;
		break;
	default:
		global_orientation = -1;
	}
}


void start_move()
{
    clearTimer(T1);
		while(time1[T1]<100)// search for 1.6 seconds
		{
			// if not detected, keep turning CCW within this 1.6 second (90 degree)  ///////////////
      differnetial_drive(1,1);// go straight
		}
}


// return true if ball is detected, otherwise, keep searching
bool search_ball()
{
	while(true) // keep searching
	{
		clearTimer(T1);
		while(time1[T1]<1800) // search for 1.6 seconds (level 1),,, level2 -- 0.8 sec
		{
			if(ballDetected) // if either L1 or L3 detect something
			{
				differnetial_drive(0,0); //stop
				return true;
			}
			if (enemyDetected)
	    {
	    	differnetial_drive(0,0);
	    	wait1Msec(500);
	  	}

			// if not detected, keep turning CCW within this 1.6 second (90 degree)  ///////////////
      differnetial_drive(-2, 2); // rotate CCW
		}
		return false;
	}

}


bool move_to_ball()
{
	while (ballDetected)
  {
  	//move towards the ball
		//adjust the speed according to the distance
		if (catchmentReady == true)
	  {
			differnetial_drive(0,0);
			wait1Msec(1000);
			catch_ball();
			return true;
	  }
	  else{
	    differnetial_drive(0.7,0.7);
	    wait1Msec(100);
	  }
  }
  return false;
}



void wait_for_on()
{
	while(SensorValue[startSwitch] == 0)
	{
		// while start switch not activated, wait inside the loop
	}

	// start the tasks (multi-tasking parallel thread)
	startTask(competition);
	// startTask(detection); // start parallel program for ball detection

}

/*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------Tasks (Parallel-runing programs (threads))------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*/

task competition()
{
	start_move();         // move half of arena first
  //startTask(detection_others);
	//startTask(detection); // start parallel program for ball detection

	while(true)
	{
		if(search_ball()) // check if the ball is detected from either L1 or L3
		{
			if(move_to_ball())
			{
				differnetial_drive(0,0); // stop
				wait1Msec(500);
				release_ball();
			}
		}
	}//end of while true
}



task detection()
{
	// this will always run in the background
	while(true)
	{
		if (SensorValue[enemyDistanceSensor] > 550)     //L1 (left) sensor detects something
		{
			enemyDetected = true;
		}
		else if (SensorValue[enemyDistanceSensor] < 550)     //L1 (left) sensor detects something
		{
			enemyDetected = false;
		}

		if((SensorValue[shortDistanceSensor] > 100 || SensorValue[longDistanceSensor] > 350) && enemyDetected == false)
	  {
			ballDetected = true;
		}

		if((SensorValue[longDistanceSensor] > 1500 || SensorValue[shortDistanceSensor] > 500)  && enemyDetected == false)    //L2 (middle) sensor detects the enemy
		{
			// 1900, 750
			catchmentReady = true;
		}
		else{
			ballDetected = false;
			catchmentReady = false;
		}
	}//end of while

	return;
}//end of task
//-------------------------------------------------------------------------------



task detection_others()
{
	while(true)
	{
		read_orientation();									//read compass orientation, store it to global_orientation

		/*--------------------------Read bumpers---------------*/
		/*
		if (SensorValue(leftBumper) == 1)
		{
			leftBumperPressed= true;
		}
		else if(SensorValue(leftBumper)==0)
		{
			leftBumperPressed= false;
		}
		if (SensorValue(rightBumper) == 1)
		{
			rightBumperPressed= true;
		}
		else if(SensorValue(rightBumper)==0)
		{
			rightBumperPressed=false;
		}
		if(SensorValue(rearBumper)==1)
		{
			rearBumperPressed=true;
		}
		else if(SensorValue(rearBumper)==0)
		{
			rearBumperPressed=false;
		}
		*/
		/*--------------------------end of Read bumpers---------------*/
	}//end of while
}







// main task
task main()
{
  startTask(detection_others);
	startTask(detection); // start parallel program for ball detection

	wait_for_on();
	while(true)
  {
  	wait1Msec(1);
    // Keep the program alive
  }
}//end of main
