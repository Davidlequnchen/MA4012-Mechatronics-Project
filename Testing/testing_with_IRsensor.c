#pragma config(Sensor, in1,    L1,             sensorAnalog)
#pragma config(Sensor, in2,    L2,             sensorAnalog)
#pragma config(Sensor, in3,    L3,             sensorAnalog)
#pragma config(Sensor, in4,    S1,             sensorAnalog)
#pragma config(Sensor, dgtl1,  startSwitch,    sensorTouch)
#pragma config(Sensor, dgtl2,  reflectiveFL,   sensorDigitalIn)
#pragma config(Sensor, dgtl3,  reflectiveFR,   sensorDigitalIn)
#pragma config(Sensor, dgtl4,  reflectiveBL,   sensorDigitalIn)
#pragma config(Sensor, dgtl5,  reflectiveBR,   sensorDigitalIn)
#pragma config(Motor,  port2,           leftWheel,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightWheel,    tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//---------------------------function definitions----------------------------------
void differnetial_drive (float leftLevel, float rightLevel);
bool search_ball();
bool move_to_ball();
//---------------------------tasks definitions-------------------------------------
task competition();
task detection();
//---------------------------global variable definitions---------------------------
//bool ballDetected = false;
bool sensorL1Detected = false;
bool sensorL2Detected = false;
bool sensorL3Detected = false;
//bool sensorS1Detected = false;
//int distanceL1 = 0;
//int distanceL2 = 0;
//int distanceL3 = 0;
//int distanceS1 = 0;


/*--- differential drive -----
direction: 1 (forward), -1 (backward)
speedMode: 0(stop), 1(1/4 speed),2,3,4(max speed), minus/plus sign
*/
void differnetial_drive(float leftLevel, float rightLevel)
{
	float voltageRight;
	float voltageLeft;

	voltageLeft = leftLevel*30;
	voltageRight = rightLevel*30;

	motor[rightWheel] = -voltageRight;
	motor[leftWheel]  = voltageLeft;
}


/*
First action, move half of the arena
*/
void start_move()
{
    clearTimer(T1);
		while(time1[T1]<1000) // search for 1.6 seconds
		{

			// if not detected, keep turning CCW within this 1.6 second (90 degree)  ///////////////
      differnetial_drive(3,3); // go straight
		}

}


// return true if ball is detected, otherwise, keep searching
bool search_ball()
{
	while(true) // keep searching
	{
		clearTimer(T1);
		while(time1[T1]<1800) // search for 1.6 seconds (level 1),,, level2 -- 0.8 sec
		{
			if(sensorL1Detected || sensorL3Detected) // if either L1 or L3 detect something
			{
				differnetial_drive(0,0); //stop
				return true;
			}
			// if not detected, keep turning CCW within this 1.6 second (90 degree)  ///////////////
      differnetial_drive(-1.7, 1.7); // rotate CCW
		}

		clearTimer(T1);
		while(time1[T1]<2*1800)
		{
			if(sensorL1Detected || sensorL3Detected) // if either L1 or L3 detect something
			{
				differnetial_drive(0,0); //stop
				return true;
			}
			// if not detected, keep turning CW within this period (180 degree)
			differnetial_drive(1.7, -1.7);    //rotate CW
		}


		clearTimer(T1);
		while(time1[T1]<1800)
		{
			if(sensorL1Detected || sensorL3Detected)
			{
				differnetial_drive(0,0); //stop
				return true;
			}
			differnetial_drive(-1.7, 1.7); // rotate CCW
		}



		//if ball is not detected during rotation searching,
		clearTimer(T1);
		while(time1[T1]<1800)
		{
			differnetial_drive(1.7, 1.7);  // move forward for 1 second
		}

		return false;
	}

}


bool move_to_ball()
{
	if (sensorL1Detected) // left IR sensor detected ball
	{
		differnetial_drive(3, 1);  //turn clockwise for 45 degrees
		wait1Msec(1000);           // this time need to be tuned
	}
	if (sensorL3Detected) // right IR sensor detected ball
	{
		differnetial_drive(1, 3);  //turn CCW for 45 degrees
		wait1Msec(1000);           // this time need to be tuned
	}
	if (sensorL2Detected) // middle IR sensor detected enemy at front
	{
		search_ball(); // if it is enemy, go back to search ball state
		return false;
	}
	// else, L2 detects nothing, there is no enemy at front
	else{
		// go straight fetch the ball
		while( SensorValue[L1] > 1450 || SensorValue[L3] > 1450) // while either of sensor not closed enough to the ball
		{
			//move towards the ball until either of the sensor reading within 12 cm
			differnetial_drive(2,2);

		}

		differnetial_drive(0,0); // stop immediately after the ball is within the range (12 cm)


		return true;

	}//end of move_to_ball

}



void wait_for_on()
{
	while(SensorValue[startSwitch] == 0)
	{
		// while start switch not activated, wait inside the loop
	}

	// start the tasks (multi-tasking parallel thread)
	startTask(competition);
	// startTask(detection); // start parallel program for ball detection

}

/*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------Tasks (Parallel-runing programs (threads))------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*/

task competition()
{
	start_move();         // move half of arena first
	startTask(detection); // start parallel program for ball detection

	while(true)
	{
		if(search_ball()) // check if the ball is detected from either L1 or L3
		{
			if(move_to_ball())
			{
				differnetial_drive(0,0); // stop
			}
		}
	}//end of while true
}



task detection()
{
	// this will always run in the background
	while(true)
	{
		// sensor output converted to actual distance value
		//distanceL1 = 18000/(SensorValue[L1]-100) ;
	  //distanceL2 = 18000/(SensorValue[L2]-100) ;
		//distanceL3 = 18000/(SensorValue[L3]-100) ;
		//distanceS1 = 9250/(SensorValue[S1]+10) ;

		if(SensorValue[L1] > 500) 		                              //L1 (left) sensor detects something
		{
			sensorL1Detected = true;
			differnetial_drive(0,0); // stop
		}
		if(SensorValue[L2] > 500) 		                              //L2 (middle) sensor detects the enemy
		{
			sensorL2Detected = true;
			differnetial_drive(0,0); // stop
		}
		if(SensorValue[L3] > 500) 		                              //L2 (middle) sensor detects the enemy
		{
			sensorL3Detected = true;
			//differnetial_drive(0,0); // stop
		}
		else{
			sensorL1Detected = false;
			sensorL2Detected = false;
			sensorL3Detected = false;
		}

	}//end of while

	return;
}//end of task


// main task
task main()
{
	//startTask(detection); // start parallel program for ball detection
	wait_for_on();
	while(true)
  {
  	wait1Msec(1);
    // Keep the program alive
  }
}//end of main
