#pragma config(Sensor, in1,    L1,             sensorAnalog)
#pragma config(Sensor, in2,    L2,             sensorAnalog)
#pragma config(Sensor, in3,    L3,             sensorAnalog)
#pragma config(Sensor, in4,    S1,             sensorAnalog)
#pragma config(Sensor, dgtl1,  startSwitch,    sensorTouch)
#pragma config(Sensor, dgtl2,  reflectiveFL,   sensorDigitalIn)
#pragma config(Sensor, dgtl3,  reflectiveFR,   sensorDigitalIn)
#pragma config(Sensor, dgtl4,  reflectiveBL,   sensorDigitalIn)
#pragma config(Sensor, dgtl5,  reflectiveBR,   sensorDigitalIn)
#pragma config(Motor,  port2,           leftWheel,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightWheel,    tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//---------------------------function definitions----------------------------------
// void move(int direction, int speedMode);
// void rotate(int direction, int speedMode);
void differnetial_drive (int leftLevel, int rightLevel);
bool search_ball();
bool move_to_ball();
//---------------------------tasks definitions-------------------------------------
task competition();
task detection();
//---------------------------global variable definitions---------------------------
bool ballDetected = false; 
bool sensorL1Detected = false;
bool sensorL2Detected = false;
bool sensorL3Detected = false;
bool sensorS1Detected = false;
int distanceL1 = 0;
int distanceL2 = 0;
int distanceL3 = 0;
int distanceS1 = 0;



// /*--- linear motion-----
// direction: 1 (forward), -1 (backward)
// speedMode: 0(stop), 1(1/4 speed),2,3(max speed)
// */
// void move(int direction, int speedMode)
// {
// 	int voltageLeft;
// 	int voltageRight;
// 	if(speedMode==1)
// 	{
// 		voltageLeft=30;
// 		voltageRight=30;
// 	}
// 	else if(speedMode==2)
// 	{
// 		voltageLeft=60;
// 		voltageRight=60;
// 	}
// 	else if(speedMode==3)
// 	{
// 		voltageLeft=120;
// 		voltageRight=120;
// 	}
// 	else if(speedMode==0)
// 	{
// 		voltageLeft=0;
// 		voltageRight=0;
// 	}
// 	motor[rightWheel] = -voltageRight*direction;
// 	motor[leftWheel]  = voltageLeft*direction;
// }

// // direction: 1: CCW, -1: CW. speed mode 0123
// void rotate(int direction, int speedMode)
// {
// 	int voltage;
// 	if(speedMode==1)
// 	{
// 		voltage=40;
// 	}
// 	else if(speedMode==2)
// 	{
// 		voltage=60;
// 	}
// 	else if(speedMode==0)
// 	{
// 		voltage=0;
// 	}
// 	motor[rightWheel] = -voltage*direction;
// 	motor[leftWheel]  = -voltage*direction;
// }



/*--- differential drive -----
direction: 1 (forward), -1 (backward)
speedMode: 0(stop), 1(1/4 speed),2,3,4(max speed), minus/plus sign
*/
void differnetial_drive(int leftLevel, int rightLevel)
{
	int voltageRight;
	int voltageLeft;

	voltageLeft = leftLevel*30; 
	voltageRight = rightLevel*30;
	
	motor[rightWheel] = voltageRight;
	motor[leftWheel]  = -voltageLeft;
}


/*
First action, move half of the arena
*/
void start_move()
{
	clearTimer(T1);
	while(time1(T1)<2000)  // move for a while
	{
		differnetial_drive(3,3); // max speed
	}
}





// return true if ball is detected, otherwise, keep searching
bool search_ball()
{
	while(true)
	{
		clearTimer(T1);
		while(time1[T1]<1000) // search for 10 seconds
		{
			if(sensorL1Detected || sensorL3Detected)
			{
				differnetial_drive(0,0); //stop
				return true;
			}
			// if not detected, turn CCW
            differnetial_drive(-1, 1); // rotate CCW
		}  

		clearTimer(T1);
		while(time1[T1]<2*700)	
		{
			if(sensorL1Detected || sensorL3Detected)
			{
				differnetial_drive(0,0); //stop
				return true;
			}
			// if not detected, turn CW
			differnetial_drive(1,-1);    //rotate CW
		}

		clearTimer(T1);
		while(time1[T1]<600)
		{
			if(sensorL1Detected || sensorL3Detected)
			{
				differnetial_drive(0,0); //stop
				return true;
			}
			differnetial_drive(-1, 1); // rotate CCW
		}


		differnetial_drive(0,0); //stop

		//if ball is not detected during rotation searching, 
		clearTimer(T1);
		while(time1[T1]<1000)	
		{
			differnetial_drive(1, 1);  // move forward for a while
		}

		return false;
	}

	return false;
}


bool move_to_ball()
{
	if (sensorL1Detected) // left IR sensor detected ball
	{
		differnetial_drive(1,-1);  //turn clockwise for 45 degrees
		wait1Msec(1000);           // this time need to be tuned
	}
	if (sensorL3Detected) // right IR sensor detected ball
	{
		differnetial_drive(-1,1);  //turn CCW for 45 degrees
		wait1Msec(1000);           // this time need to be tuned
	}
	if (sensorL2Detected) // middle IR sensor detected enemy at front
	{
		search_ball(); // if it is enemy, go back to search ball state
		return false;
	}
	else{
		while( distanceL1 > 12 || distanceL3 > 12) // while either of sensor not closed enough to the ball
		{
				//move towards the ball until either of the sensor reading within 12 cm
				differnetial_drive(1,1);
		}
		differnetial_drive(0,0); // stop immediately after the ball is within the range
	return true;
}//end of move_to_ball

	}



void wait_for_on()
{
	while(SensorValue[startSwitch] == 0)
	{
		// while start switch not activated, wait inside the loop
	}
	// differnetial_drive(1,1); // move straight ahead
	// wait1Msec(1000);//wait one second

	// start the tasks (multi-tasking parallel thread)
	startTask(competition);
}

/*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------Tasks (Parallel-runing programs (threads))------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*/

task competition()
{
	startTask(detection); // start parallel program for ball detection
	start_move();         // move half of arena first

	while(true)
	{
		if(search_ball()) // check if the ball is found from L1 or L3
		{
			if(move_to_ball())
			{
				differnetial_drive(0,0); // stop
				
			}
		}
	}//end of while true
}



task detection()
{
	while(true)
	{   
		// sensor output to actual distance value
		distanceL1 = 18000/(SensorValue[L1]-100) ;
	    distanceL2 = 18000/(SensorValue[L2]-100) ;
		distanceL3 = 18000/(SensorValue[L3]-100) ;
		distanceS1 = 9250/(SensorValue[S1]+10) ;


		if(distanceL1< 40) 		                              //L1 (left) sensor detects something
		{
			sensorL1Detected = true; 
		}
		else {
			sensorL1Detected = false;
		}
		if(distanceL2< 40) 		                              //L2 (middle) sensor detects the enemy
		{
			sensorL2Detected = true; 
		}
		else{
			sensorL2Detected = false;
		}
		if(distanceL3< 40) 		                              //L3 (right) sensor detects something
		{
			sensorL3Detected = true; 
		}else{
			sensorL3Detected = false;
		}

		if(distanceS1< 20) 		                              //S1 (back) sensor detects opponents
		{
			sensorS1Detected = true; 
		}else{
			sensorS1Detected = false;
		}  

	}//end of while
}//end of task


// main task
task main()
{
	wait_for_on();
	//while(true)
	//{
		// runing until told to stop
	//}
}//end of main
